
    {-# STDLIB_VERSION 5 #-}
    {-# CONTENT_TYPE DAPP #-}
    {-# SCRIPT_TYPE ACCOUNT #-}
    
    let layer1Weights = [[6004965, 6007324], [4141966, 4142525]]
    let layer1Biases = [-2590503, -6356371]
    let layer2Weights = [[8329656, -8971418]]
    let layer2Biases = [-3811788]
    
    
    func sigmoid(z: Int) = {
        let e = 2718281
        let base = 1000000
        let positiveZ = if (z < 0) then -z else z
        let expPart = fraction(e, base, positiveZ)
        fraction(base, base, base + expPart)
    }

    
        func forwardPassLayer1(input: List[Int], weights: List[List[Int]], biases: List[Int]) = {
            let sum0 = fraction(input[0], weights[0][0], 1000000) + fraction(input[1], weights[0][1], 1000000) + biases[0]
    let sum1 = fraction(input[0], weights[1][0], 1000000) + fraction(input[1], weights[1][1], 1000000) + biases[1]
            let sig0 = sigmoid(sum0)
    let sig1 = sigmoid(sum1)
            [sig0, sig1]
        }
        
        func forwardPassLayer2(input: List[Int], weights: List[Int], bias: Int) = {
            let dotProduct = fraction(input[0], weights[0], 1000000) + fraction(input[1], weights[0], 1000000)
            let sum = dotProduct + bias
            sigmoid(sum)
        }
        

    @Callable(i)
func predict(input1: Int, input2: Int) = {
    let scaledInput1 = if(input1 == 1) then 1000000 else 0
    let scaledInput2 = if(input2 == 1) then 1000000 else 0
    let inputs = [scaledInput1, scaledInput2]
    let layer1Output = forwardPassLayer1(inputs, layer1Weights, layer1Biases)
    let output = forwardPassLayer2(layer1Output, [8329656, -8971418], -3811788)
    [
        IntegerEntry("result", output)
    ]
}
    