
    {-# STDLIB_VERSION 5 #-}
    {-# CONTENT_TYPE DAPP #-}
    {-# SCRIPT_TYPE ACCOUNT #-}
    
    let layer1Weights = [[-9275240, 6222139], [-9201827, -6516189], [-1528731, 11450396], [-7524843, -6044814]]
    let layer1Biases = [-2569627, 2312524, -4752973, 1895166]
    let layer2Weights = [[-7575203, 5523326, 6581110, 3773202], [6861028, -5706216, -6035509, -3323542]]
    let layer2Biases = [-3161622, 2945010]
    let layer3Weights = [[-8939640, 9517362]]
    let layer3Biases = [-192349]
    
    
    func sigmoid(z: Int) = {
        let e = 2718281
        let base = 1000000
        let positiveZ = if (z < 0) then -z else z
        let expPart = fraction(e, base, positiveZ)
        fraction(base, base, base + expPart)
    }

    
        func forwardPassLayer1(input: List[Int], weights: List[List[Int]], biases: List[Int]) = {
            let sum0 = fraction(input[0], weights[0][0], 1000000) + fraction(input[1], weights[0][1], 1000000) + fraction(input[2], weights[0][2], 1000000) + fraction(input[3], weights[0][3], 1000000) + biases[0]
    let sum1 = fraction(input[0], weights[1][0], 1000000) + fraction(input[1], weights[1][1], 1000000) + fraction(input[2], weights[1][2], 1000000) + fraction(input[3], weights[1][3], 1000000) + biases[1]
    let sum2 = fraction(input[0], weights[2][0], 1000000) + fraction(input[1], weights[2][1], 1000000) + fraction(input[2], weights[2][2], 1000000) + fraction(input[3], weights[2][3], 1000000) + biases[2]
    let sum3 = fraction(input[0], weights[3][0], 1000000) + fraction(input[1], weights[3][1], 1000000) + fraction(input[2], weights[3][2], 1000000) + fraction(input[3], weights[3][3], 1000000) + biases[3]
            let sig0 = sigmoid(sum0)
    let sig1 = sigmoid(sum1)
    let sig2 = sigmoid(sum2)
    let sig3 = sigmoid(sum3)
            [sig0, sig1, sig2, sig3]
        }
        
        func forwardPassLayer2(input: List[Int], weights: List[List[Int]], biases: List[Int]) = {
            let sum0 = fraction(input[0], weights[0][0], 1000000) + fraction(input[1], weights[0][1], 1000000) + biases[0]
    let sum1 = fraction(input[0], weights[1][0], 1000000) + fraction(input[1], weights[1][1], 1000000) + biases[1]
            let sig0 = sigmoid(sum0)
    let sig1 = sigmoid(sum1)
            [sig0, sig1]
        }
        
        func forwardPassLayer3(input: List[Int], weights: List[Int], bias: Int) = {
            let dotProduct = fraction(input[0], weights[0], 1000000) + fraction(input[1], weights[0], 1000000)
            let sum = dotProduct + bias
            sigmoid(sum)
        }
        

    @Callable(i)
func predict(input1: Int, input2: Int) = {
    let scaledInput1 = if(input1 == 1) then 1000000 else 0
    let scaledInput2 = if(input2 == 1) then 1000000 else 0
    let inputs = [scaledInput1, scaledInput2]
    let layer1Output = forwardPassLayer1(inputs, layer1Weights, layer1Biases)
    let layer2Output = forwardPassLayer2(layer1Output, layer2Weights, layer2Biases)
    let output = forwardPassLayer3(layer2Output, [-8939640, 9517362], -192349)
    [
        IntegerEntry("result", output)
    ]
}
    