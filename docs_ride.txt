Getting started
Introduction
Ride is a purpose-designed programming language for smart contracts on the Waves blockchain. It was created to address many of the most serious shortcomings of other popular smart contract languages. The overall idea was to offer a straightforward functional language for dApp development on the Waves blockchain.

Ride is easy to learn, especially for beginning developers. This article gives a comprehensive introduction to Ride, along with examples and further tools and resources.

Overview
Ride is a statically-typed, lazy, functional, expression-based compiled programming language. It is designed for building developer-friendly decentralized applications (dApps).

Ride is not Turing Complete and its execution engine (virtual machine) doesn’t have any concept of loops. Also, there are a number of limitations by design, helping to ensure execution is secure and straightforward. However, we recognize that iterations are necessary and have implemented them as FOLD macros (see below). One of the key features is that the execution cost is always predictable and known in advance.

Despite being simple to use, however, Ride is powerful and offers wide-ranging functionality to developers. It’s broadly based on Scala and is also influenced by F# and the functional paradigm.

Ride is simple and concise. It will take around an hour to read this brochure, after which you will know everything about the Ride and opportunities that it gives for dApps development.

“Hello world!”
Let’s start with a familiar example:

func say() = {
  "Hello world!"
}
Functions in Ride are declared with func (see further below). Functions do have return types, this is inferred automatically by the compiler, so you don't have to declare them. In the case above the function say returns the string Hello World!. There is no return statement in the language because Ride is expression-based (everything is an expression), and the last statement is a result of the function.

Blockchain
Ride was created specifically for execution within a blockchain environment and is optimised for this purpose. Because the blockchain is a shared ledger, located on many computers all around the world, it works a little differently to conventional programming languages.

Since Ride is designed to be used inside the blockchain, there is no way to access the filesystem or display anything in the console. Instead, Ride functions can read data from the blockchain and return actions as a result, which can then be applied to the blockchain.

Comments
You can add comments to your code much as you can with other languages such as Python:

# This is a comment line

# And there is no multiline comments

"Hello world!" # You can write comments like here
Directives
Every Ride script should start with directives for the compiler. At the time of publication, there are three types of directive, with different possible values.

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
STDLIB_VERSION sets the version of the standard library. The latest version currently in production is 8.

CONTENT_TYPE sets the type of the file you're working on. There are different content types, DAPP and EXPRESSION. The DAPP type allows you to define functions and finish execution with certain actions which result in account balances, asset properties, and entries in the dApp account data storage. The EXPRESSION type should always return a boolean value, since it’s used as a predicate for transaction validation.

SCRIPT_TYPE sets the entity type we want to add to the script to change its default behavior. Ride scripts can be attached to either an ACCOUNT or ASSET.

Not all combinations of directives are correct. The example below won’t work, because DAPP content type is allowed only for accounts, while EXPRESSION type is allowed for assets and accounts.

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ASSET #-} # dApp content type is not allowed for an asset
Variables
Variables are declared and initialized with the let keyword.

let a = "Bob"
let b = 1
All variables in Ride are immutable. This means you cannot change the value of a variable after declaration.

Ride is strongly typed and the variable's type is inferred from the value on the right hand side.

Ride allows you to define variables globally, inside any function, or even inside a variable definition.

func lazyIsGood() = {
  let a = "Bob"
  let b = {
     let x = 1
     “Alice”
    }  
  true
}
The function above will compile and return true as a result, but variable a won't be evaluated because initialization via let is lazy: unused variables are not evaluated. For strict (eager) initialization, use the strict keyword.

Functions
Functions in Ride can only be used after they are declared.

func greet(name: String) = {
  "Hello, " + name
}

func add(a: Int, b: Int) = {
  func m(a:Int) = a
  m(a) + b
}
The type (Int, String, etc) comes after the argument’s name.

As in many other languages, functions should not be overloaded. It helps to keep the code simple, readable and maintainable.

func calc() = {
  42
}

func do() = { 
  let a = calc()
  true
}
The calc function will not be called either, because variable a is unused.

Unlike most languages, variable shadowing is not allowed. Declaring a variable with a name that is already used in a parent scope will result in a compilation error.

Functions should be defined before they are used.

Functions can be invoked in prefix and postfix order:

let list = [1, 2, 3]
let a1 = list.size()
let a2 = size(list)

let b1 = getInteger(this, “key”)
let b2 = this.getInteger(“key”)
In these examples a1 is the same as a2 and b1 is the same as b2.

Basic types
The main basic types and examples are listed below:

Boolean    #   true
String     #   "Hey"
Int        #   1610
ByteVector #   base58'...', base64'...', base16'...', fromBase58String("...") etc.
We will explore Strings and special types further below.

Strings
let name = "Bob"   # use "double" quotes only
let coolName = name + " is cool!" # string concatenation by + sign

name.indexOf("o")  # 1
Like other data structures in Ride, strings are immutable. String data is encoded using UTF-8.

Only double quotes can be used to denote strings. Strings are immutable, just like all other types. This means that the substring function is very efficient: no copying is performed and no extra allocations are required.

All operators in Ride must have values of the same type on both sides. The following code will not compile because age is an int:

let age = 21
"Bob is " + age # won't compile
To make it work we have to convert age to string:

let age = 21
"Alice is " + age.toString() # will work!
Special types
Ride has few core types, which operate much as they do in Scala.

Unit
There is no null in Ride, as is the case in many other languages. Usually, built-in functions return unit value of type unit instead of null.

"String".indexOf("substring") == unit # true
Nothing
Nothing is the 'bottom type' of Ride’s type system. No value can be of type Nothing, but an expression of type Nothing can be used everywhere. In functional languages, this is essential for support for throwing an exception:

2 + throw() # the expression compiles because
    # there's a defined function +(Int, Int).
      # The type of the second operand is Nothing, 
      # which complies to any required type.
List
let list = [16, 10, 1997, "birthday"]       # can contain different data types

let second = list[1]                        # 10 - read second value from the list
List doesn't have any fields, but there are functions and operators in the Standard library that make it easier to work with fields.

let list = [16, 10, 1997, "birthday"]

let last = list[(list.size() - 1)] # "birthday", postfix call of size() function

let lastAgain = getElement(list, size(list) - 1) # the same as above
.size() function returns the length of a list. Note that it's a read-only value, and it cannot be modified by the user. (Note also that last could be of more than one type, but this is only inferred when the variable is set.)

let initList = [16, 10]                   # init value
let newList = cons(1997, initList)        # [1997, 16, 10]
let newList2 = 1997 :: initList           # [1997, 16, 10]
let newList2 = initList :+ 1              # [16, 10, 1]
let newList2 = [4, 8, 15, 16] ++ [23, 42]     # [4 8 15 16 23 42]
To prepend an element to an existing list, use the cons function or :: operator
To append an element, use the :+ operator
To concatenate 2 lists, use the ++ operator
Tuple
Tuple is an ordered collection of elements. Elements can be of any type.

let x=("Hello Waves",42,true)
let num = x._2                                # 42
let (a,b,c) = x
let bool = c                                  # true
Union Types & Type Matching
let valueFromBlockchain = getString("3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf", "someKey") # Union(String | Unit)
Union types are a very convenient way to work with abstractions. Union(String | Unit) shows that the value is an intersection of these types.

The simplest example of Union types is given below (please bear in mind that defining custom user types in dApp code will be supported in future versions):

type Human : { firstName: String, lastName: String, age: Int}
type Cat : {name: String, age: Int }
Union(Human | Cat) is an object with one field, age, but we can use pattern matching:

Human | Cat => { age: Int }
Pattern matching is designed to check a value against value type:

  let t = ...               # Cat | Human
  t.age                     # OK
  t.name                    # Compiler error
  let name = match t {      # OK
    case h: Human => h.firstName
    case c: Cat   => c.name
  }
Type matching is a mechanism for:

let amount = match tx {              # tx is a current outgoing transaction
  case t: TransferTransaction => t.amount
  case m: MassTransferTransaction => m.totalAmount
  case _ => 0
}
The code above shows an example of type matching. There are different types of transactions in Waves, and depending on the type, the real amount of transferred tokens can be stored in different fields. If a transaction is TransferTransaction or MassTransferTransaction we use the corresponding field, while in all other cases, we will get 0.

Data Reading Functions
let readOrZero = match getInteger(this, "someKey") { # reading data
    case a:Int => a
    case _ => 0
}

readOrZero + 1
getString returns Union(String | Unit) because while reading data from the blockchain (the key-value data storages of accounts) some key-value pairs may not exist.

let v = getInteger("3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf", "someKey")
v + 1    # doesn’t compile, forcing a developer to foresee the possibility of non-existing value for the key

v.valueOrErrorMessage(“oops”) +  1 # compiles and executes

let realStringValue2 = getStringValue(this, "someKey")
To get the real type and value from Union use the value function, which will terminate the script in case of unit value. Another option is to use specialized functions like getStringValue, getIntegerValue, etc.

If
let amount = 1610
if (amount > 42) then "I claim that amount is bigger than 42"
  else if (amount > 100500) then "Too big!"
  else "I claim something else"
if statements are pretty straightforward and similar to most other languages, with an important difference from some: if is an expression, so it must have an else clause (the result is assignable to a variable).

let a = 16
let result = if (a > 0) then a / 10 else 0 #
Exceptions
throw("Here is exception text")
The throw function will terminate script execution immediately, with the provided text. There is no way to catch thrown exceptions.

The idea of throw is to stop execution and send useful feedback to the user.

let a = 12
if (a != 100) then
  throw ("a is not 100, actual value is " + a.toString())
  else throw("A is 100")
Predefined Data Structures
#LET THE HOLY WAR BEGIN

Ride has many predefined data structures specific to the Waves blockchain, such as: Address, Alias, Invocation, Issue, Lease, ScriptTransfer, StringEntry, ExchangeTransaction, SetScriptTransactions.

let keyValuePair = StringEntry("someKey", "someStringValue")
For example, StringEntry is a structure which describes a key-value pair with string value, e.g. for an account data storage.

All structures can be used for type checking, pattern matching and their constructors as well.

Loops With FOLD<N>
Since Ride’s virtual machine doesn’t have any concept of loops, they are implemented at compiler level via the FOLD<N> macro. The macro behaves like the ‘fold’ function in other programming languages, taking the input arguments: collection for iteration, starting values of the accumulator and folding function.

The important aspect is N - the maximum amount of interactions over collections. This is necessary for maintaining predictable computation costs.

This code sums the numbers of the array:

let a = [1, 2, 3, 4, 5]
func foldFunc(acc: Int, e: Int) = acc + e
FOLD<5>(a, 0, foldFunc) # returns 15
FOLD<N> can also be used for filtering, mapping, and other operations. Here’s an example for map with reverse:

let a = [1, 2, 3, 4, 5]
func foldFunc(acc: List[Int], e: Int) = (e + 1) :: acc
FOLD<5>(a, [], foldFunc) # returns [6, 5, 4, 3, 2]
Annotations
Functions can be without annotations, or with @Callable or @Verifier annotations. Annotated function are used only in scripts of type DAPP.

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

func getPayment(i: Invocation) = {
  if (size(i.payments) == 0)
    then throw("Payment must be attached")
    else {
      let pmt = i.payments[0]
      if (isDefined(pmt.assetId))
        then throw("This function accepts WAVES tokens only")
        else pmt.amount
    }
}

@Callable(i)
func pay() = {
  let amount = getPayment(i)
  (
    [
      IntegerEntry(toBase58String(i.caller.bytes), amount)
    ],
    unit
  )
}
Annotations can bind some values to the function. In the example above, variable i was bound to the function pay and stored some fields of the invocation (the caller’s public key, address, payments attached to the invocation, fee, transaction ID etc.).

Functions without annotations are not available from the outside. You can call them only inside other functions.

Verifier Function
@Verifier(tx)
func verifier() = {
  match tx {
    case ttx: TransferTransaction => ttx.amount <= 100 # can send up to 100 tokens
    case _ => false
  }
}
A function with the @Verifier annotation sets the rules for outgoing transactions of a decentralized application (dApp). Verifier functions cannot be called from the outside, but they are executed every time an attempt is made to send a transaction from a dApp.

Verifier functions should always return a Boolean value as a result, depending on which a transaction will be recorded to the blockchain or not.

Expression scripts (with directive {-# CONTENT_TYPE EXPRESSION #-}) along with functions annotated by @Verifier should always return a boolean value. Depending on that value the transaction will be accepted (in case of true) or rejected (in case of false) by the blockchain.

@Verifier(tx)
func verifier() = {
  sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
}
The Verifier function binds variable tx, which is an object with all fields of the current outgoing transaction.

A maximum of one @Verifier() function can be defined in each dApp script.

Callable Function
Functions with the @Callable annotation can be called (or invoked) from other accounts: by an Invoke Script transaction or by a dApp.

A callable function can perform actions: write data to the dApp data storage, transfer tokens from the dApp to other accounts, issue/release/burn tokens, and others. The result of a callable function is a tuple of two elements: a list of structures describing script actions and a value passed to the parent function in case of the dApp-to-dApp invocation.

@Callable(i)
func giveAway(age: Int) = {
  (
    [
      ScriptTransfer(i.caller, age, unit),
      IntegerEntry(toBase58String(i.caller.bytes), age)
    ],
    unit
  )
}
Every caller of giveAway function will receive as many WAVELETs as their age. The ScriptTransfer structure sets the parameters of the token transfer. dApp also will store information about the fact of the transfer in its data storage. The IntegerEntry structure sets the parameters of the entry: key and value.

Testing and Tools
You can try out Ride in REPL both online at https://waves-ide.com/ and on desktop via terminal with surfboard:

> npm i -g @waves/surfboard
> surfboard repl
For further development, the following tools and utilities are useful:

Visual Studio Code plugin: waves-ride
The surfboard tool for compiling Ride smart contracts and running tests: https://github.com/wavesplatform/surfboard
Online IDE with examples: https://waves-ide.com/
Further information about tools

Syntax Basics
Ride is a functional programming language based on expressions.

Ride features:

strong static typing
no loops and goto-like expressions, and therefore Ride is not Turing complete
case-sensitivity.
Base concepts:

Directives
Definition
Expression
Variable
Function
Exception
Comments
Complexity

Directives
Every Ride script should start with directives for the compiler. The directives define the script format and available built-in functions, structures, and variables.

Directive format is as follows:

{-# DIRECTIVE_NAME VALUE #-}
Directives List
Directive name	Description	Possible values
STDLIB_VERSION	Version of the Standard Library	8: enabled by feature #22 “Light Node”
7: enabled by feature #19 “Block Reward Distribution”
6: enabled by feature #17 “Ride V6, MetaMask support”
5: enabled by feature #16 “Ride V5, dApp-to-dApp invocations”
4: enabled by feature #15 “Ride V4, VRF, Protobuf, Failed transactions”
3
2
1
CONTENT_TYPE	Script content type	DAPP: the script is a set of definitions and contains functions that can be invoked from another account.
EXPRESSION: the script is a boolean expression expression used for transaction verification
SCRIPT_TYPE	Script usage	ACCOUNT: the script is assigned to account
ASSET: the script is assigned to asset
LIBRARY: the script can be imported into other scripts as a library
IMPORT	Libraries to import	Names of the libraries saved in Waves IDE
Directives Examples
For a dApp script:

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
For an account script:

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}
For an asset script:

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ASSET #-}
For a library script:

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE LIBRARY #-}
{-# SCRIPT_TYPE ACCOUNT #-}
Not all the combinations of directives are correct. The example below will not work, because DAPP content type is allowed only for accounts:

# Wrong example, will not work

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ASSET #-}

Definition
A definition is a linking of the name to the value or to the function body.

Examples
Linking the name to the value.

let x = 5 + 5
Linking the name to the function body.

func f(x: Int) = {
  x + 5
}

Expression
An expression is a combination of one or more constants, variables, operators and function calls.

Ride interprets the expression and calculates its result.

Expression result
An expression result is a value, which is obtained by the fold of the syntactic tree of the expression.

Expression type
An expression type is a data type of the expression result.

Examples
The expression that consists of a single constant.

7
The expression that consists of a single variable.

x
The expression that consists of the constant 7, operators + and *, variable x and the size function call.

7 + x * size("apple")

Variables
In Ride, you can only declare a variable along with a value assignment. The = sign must be followed by an expression. The value of the variable is the expression result.

Ride variables are immutable: the value of a variable cannot be changed after it is defined.

Ride is strongly typed and the variable's type is inferred from the value.

Lazy Variables
let keyword defines a variable with lazy evaluation: the variable is not evaluated immediately, but only the first time the variable is used.

Examples:

let a = 42                 # Integer variable definition
let b = "Ride the Waves!"  # String variable definition
You can define variables globally, inside any function, or even inside a variable definition.

func lazyIsGood() = {
  let c = {
     let d = 1
     true
    }  
  c
}
The function above returns true, but variable d won't be evaluated because unused lazy variables are not evaluated.

Note that lazy variables are evaluated not in the same order they are defined, but in the order they are used.

# don't do this
func foo() = {
   ...
   let balanceBefore = wavesBalance(this).regular
   let result = invoke(dApp2,"bar",args,[AttachedPayment(unit,100000000)])
   let balanceAfter = wavesBalance(this).regular

   if(balanceAfter < balanceBefore) then ... else...
}
In this example, balanceAfter would be evaluated before balanceBefore, and their values would be the same. invoke() won't be called at all.

Strict Variables
strict keyword defines a variable with strict (eager) evaluation. Unlike lazy variables defined with let, a strict variable is evaluated immediately when script execution reaches it, that is, before the next expression.

Strict variable can only be defined only inside another definition, for example, inside the body of a function. A strict variable will not be evaluated if it is defined inside another definition that is not used: for example, inside a function that has not been called.

Strict variables are suitable for dApp-to-dApp invocation as they ensure executing callable functions and applying their actions in the right order. Example:

func foo() = {
   ...
   strict balanceBefore = wavesBalance(this).regular
   strict result = invoke(dApp2,"bar",args,[AttachedPayment(unit,100000000)])
   strict balanceAfter = wavesBalance(this).regular

   if(balanceAfter < balanceBefore) then ... else...
}
This example evaluates balanceBefore first, then result with a call to invoke(), then balanceAfter. The values of balanceBefore and balanceAfter may differ because payments to dApp2 and actions performed by the bar callable function affect the balance.

Note that using lazy and strict variables together can have unexpected effects. Example:

# don't do this
{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let lpTokenId = base58'...'
let rewardTokenId = base58'...'

@Callable(i)
func burn(amount: Int) = [ Burn(lpTokenId, amount) ]

@Callable(i)
func reward() = {
   let p = value(i.payments[0])
   if p.assetId != lpTokenId
      then throw("Incorrect payment")
      else {
         let lpQty = assetInfo(lpTokenId).value().quantity
         let rewardQty = assetInfo(rewardTokenId).value().quantity
         let share = fraction(p.amount,rewardQty,lpQty)
         strict result = invoke(this, "burn", [p.amount], [])
         [
            ScriptTransfer(i.caller, share, rewardTokenId)
         ]
      }
}
The share variable is lazy, so the reward() function first calls the burn() function and then evaluates share. For example, if there are 100 LP tokens in total and a user attached 20 of them to the script invocation, then 20 LP tokens are burned first, then the share (20 LP tokens of the remaining 80) is calculated. As a result, the user receive not 20%, but 25% of the total quantity of the reward token.

Strict variables are added in Standard library version 5.

Built-in Variables
The Standard library defines built-in variables that you can use in scripts.

Functions
Functions in Ride are defined with func keyword. Functions must be defined before they are used.

A function must return a value. The function definition must have an expression to the right of the "=" sign. The return value is the expression result. There is no return statement in Ride.

The return type is inferred automatically by the compiler.

Examples
The say() function without parameters returns the string Hello World!:

func say() = {
  "Hello world!"
}
Here is a function definition with three parameters:

func main(amount: Int, assetId: ByteVector|Unit, names: List[String]) = {
   throw()
}
Function call
Functions can be invoked in prefix and postfix order:

let list = [1, 2, 3]
let a1 = list.size()
let a2 = size(list)

let b1 = getInteger(this, “key”)
let b2 = this.getInteger(“key”)
In these examples a1 is the same as a2 and b1 is the same as b2.

Built-in Functions
The Standard library defines built-in functions that you can use in scripts.

Annotations
In dApp scripts you can define callable functions and verifier function using annotations.

Exceptions
You can interrupt the script execution using the throw function:

func main(amount: Int) = {
   if (amount > 0)
   then
        "Done!"
   else
        throw("Error!")
}
There is no exception handling in Ride: after an exception has been thrown, the script execution fails. The transaction can be either discarded or saved on the blockchain as failed, see the Transaction Validation article for details.

Comments
To write comments use the pound sign.

let month = 7 # Sets the month
If the comment takes several lines, use the pound sign on each line.

# This comment
# takes
# three lines

Script complexity
Script complexity is a dimensionless value that represents computational resources required to execute the script.

The complexity of a script is the sum of complexities of all the functions and operators used. For example, the :: operator has complexity 1, and the sigVerify() function has complexity 180.

For a dApp script, the complexity of each callable function and the complexity of the verifier function are calculated separately.

Limitations on the script complexity are given in the Limitations article.

You can find out the script complexity in Waves IDE:



The actual complexity when executing the script may be less than the complexity calculated at compilation.

Functions
The complexity of built-in functions is listed in the Built-in Functions article.

The complexity of a function call is the maximum of two numbers: 1 and the complexity of the expression returned. Thus, function call has a complexity of at least 1, even if the function does nothing.

Operators
The complexity of operators is listed in the Operators article.

Conditional Statements
The complexity of a script with branches (if ... then ... else) is calculated at compilation by the most complex branch. The complexity of the condition is also taken into account.

The complexity of match ... case equals to the number of case, with each type in the union (for example, case n: Int|BigInt) counted as a separate case. If there is no default case (case _), another 1 is added to the complexity.

Structures, Tuples, Lists
The complexity of a constructor of structure or tuple is considered equal to the number of elements at compilation. The actual constructor complexity when executing the script is 1.

The complexity of creating a list is equal to the number of elements, since the expression [a, b, c] is equivalent to a :: b :: c :: nil.

Macros Expanded at Compilation
as has complexity 1.

The following code

let x = 1.as[Int]
expands into

let x = {
let @ = 1
if ($isInstanceOf(@, "Int")) # Complexity is 1
   then @
   else unit
}
exactAs has complexity 4.

let x = someExpr.exactAs[Int]
expands into

let x = {
let @ = someExpr
if ($isInstanceOf(@, "Int")) # Complexity is 1
   then @
   else throw(($getType(someExpr) + " couldn't be cast to Int"))
   # Complexity is 3: 1 for throw, 1 for getType, and 1 for "+"
}
FOLD<N>(list, start, foldFunc) has complexity 4 + N × (3 + complexity_of_foldFunc).

let x = FOLD<5>(list, 0, foldFunc)
expands into

let x = {
   let $l = list
   let $s = size($l) # Complexity is 2
   let $acc0 = 0

   # Complexity is 3 + complexity_of_foldFunc
   func $f0_1($a,$i) =
      if ($i >= $s) # Complexity is 1
         then $a
         else foldFunc($a, $l[$i]) # Complexity of foldFunc + 2 for accessing a list item

   # Complexity is 2
   func $f0_2($a,$i) =
      if ($i >= $s) # Complexity is 1
         then $a
         else throw("List size exceeds 5") # Complexity is 1

   # 1 call of $f0_2 and 5 calls of $f0_1
   $f0_2($f0_1($f0_1($f0_1($f0_1($f0_1($acc0, 0), 1), 2), 3), 4), 5)
}
strict has complexity 1. If the expression below has complexity 0, another 1 is added to the complexity at compilation.

strict x = someExpr
restExpr
expands into

let x = someExpr
if (x == x) # Complexity is 1
   then restExpr
   else throw("Strict value is not equal to itself.") # Complexity is 1

dApp Script
dApp script enables you to define callable functions that can be called from other accounts by sending an Invoke Script transaction or by a dApp-to-dApp invocation. Callable functions can accept payments to the dApp and perform various actions on the blockchain. Also dApp script can comprise a verifier function that allows or denies transactions and orders that are sent on behalf of the dApp account.

An account with a dApp script assigned to it is called a dApp. For information about how dApp works, see the What is dApp article. For information about how to create a dApp, see the Creating and Running dApp article.

dApp Script Format
The script code is composed of the following parts:

Directives
Auxiliary definitions
Callable functions
Verifier function


Directives
The dApp script should start with directives:

{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
The above directives tell the compiler that:

the script uses the Standard library version 8,
the script contains a set of definitions,
the script will be assigned to an account (not asset).
Auxiliary Definitions
After the directives, you can define auxiliary variables and functions. These variables and functions are accessible within the entire script. Please note that functions without annotations cannot be called from other accounts.

Example:

let someConstant = 42
func doSomething() = {
    1+1
}
Callable Functions
Callable function can be called from another account via the Invoke Script transaction.

The callable function should be marked with the @Callable(i) annotation, where i is an Invocation structure that contains fields of the script invocation that are accessible to the callable function. The variable name in the annotation is required even if the function does not use it.

Callable function result is a set of script actions that are performed on the blockchain: adding/deleting/modifying entries to the account data storages, token transfers, issue/reissue/burning, and others. The result format and the available actions depend on the Standard library version used.

For a detailed description, see the Callable Function article.

In the example below the callable function transfers 1 WAVES to an account that called it and records the request information in the account data storage. If the same account tries to call the function again, the callable function throws an exception.

@Callable(i)
func faucet () = {
   let isKnownCaller =  match getBoolean(this, toBase58String(i.caller.bytes)) {
      case hist: Boolean =>
         hist
      case _ =>
         false
   }
   if (!isKnownCaller) then 
      (
         [
            BooleanEntry(toBase58String(i.caller.bytes), true),
            ScriptTransfer(i.caller, 100000000, unit)
         ],
         unit
      )
   else throw("Can be used only once")
}
Verifier Function
Verifier function checks transactions and orders that are sent on behalf of the dApp account for compliance with the specified conditions (in other words it works similar to the account script).

The verifier function should be marked with the @Verifier(tx) annotation, where tx is the transaction or the order that the function is currently checking. The variable name in the annotation is required even if the function does not use it.

The verifier function has no arguments.

Possible results of the verifier function are:

true: the transaction/order is allowed,
false: the transaction/order is denied,
an error: the transaction/order is denied.
For a detailed description, see the Verifier Function article.

Using the match ... case operator, you can set up different conditions depending on the type of the transaction/order. For example, the following function allows transfer transactions and denies orders and other types of transactions.

@Verifier(tx)
func verify() = {
    match tx {
        case ttx:TransferTransaction => sigVerify(ttx.bodyBytes, ttx.proofs[0], ttx.senderPublicKey)
        case _ => false
    }
}
dApp script that has no verifier function performs default verification, that is, checking that the transaction or the order is indeed signed by this account.

Failed Transactions
If the callable function failed or threw an exception when a block generator adds the transaction to a block, such a transaction is saved on the blockchain and marked with the attribute "applicationStatus": "script_execution_failed", provided that:

the Invoke Script transaction passed the sender signature verification or the account script verification,
the complexity of performed computations exceeded the threshold for saving failed transactions.
The transaction sender is charged a fee. The transaction doesn't entail any other changes on the blockchain.

More about transaction validation

More about handling failed transactions

Data Accessible to dApp Script
Data accessible to the callable function:

Particular fields of the invocation, including payments, fee, sender address and public key. See the Invocation article for the fields description. Proofs are inaccessible.
Blockchain data: current height, account balances, entries in account data storages, parameters of tokens, etc.
As of version 5 of the Standard library, when executing a dApp script, payments attached to the invocation are considered to be already credited to the dApp balance (unlike versions 4 and 3, where payments do not affect the dApp balance until the end of script execution).

Data accessible to the verifier function:

Fields of the current verified transaction/order, including proofs. The built-in variable tx contains this transaction or order. The set of fields depends on the type of transaction/order, see the Transaction Structures chapter and Order article.

Blockchain data: current height, account balances, entries in account data storages, parameters of tokens, etc.

⚠️ Blockchain data is available only when checking a transaction and not available when checking an order (case t: Order).

Annotations
Annotation is a form of metadata that is added to a function of a dApp script.

At the present moment, there are two annotations: @Callable(i) and @Verifier(tx). The variable name in the annotation is required even if the function does not use it.

An annotated function cannot be called inside a dApp script.

@Callable(i)
Annotation of a callable function.

Variable i contains an Invocation structure representing certian fields of the invocation.

@Verifier(tx)
Annotation of a verifier function.

Variable tx contains a structure of transaction or order sent from a dApp's account.

Callable Function
Callable function is a dApp script function which can be invoked by an Invoke Script transaction or an invoke or reentrantInvoke functions (see details in the dApp-to-dApp Invocation article).

dApp script can contain multiple callable functions.

The callable function can perform the following actions:

Add, modify, delete dApp account data storage entries.
Transfer tokens.
Issue tokens on behalf of the dApp, reissue and burn tokens.
Setup sponsorship.
Lease, cancel lease.
Available script actions depend on Standard library version used.

The callable function can return a value that is passed to the invoking function in case of the dApp-to-dApp invocation.

The invocation can contain payments to dApp. Tokens obtained in these payments can be used in script actions performed by the callable function and in payments attached to nested invocations.

⚠️ The fee for the Invoke Script transaction cannot be funded by transfer from the dApp to the transaction sender after activation of feature #15 “Ride V4, VRF, Protobuf, Failed transactions”. If sender's balance is insufficient to pay the fee, dApp script is not executed.

Annotation
The callable function should be marked with the @Callable(i) annotation, where i is an Invocation structure that contains invocation fields that are available to the callable function. The variable name in the annotation is required even if the callable function does not use it.

Arguments
The callable function can have arguments of the following types:

Boolean,

ByteVector,

Int,

String,

List which contains elements of one of the above types the types listed above, for example, List[String].

⚠️ Nested lists are not allowed as arguments to a callable function (unlike function without annotation).

Invocation Result
The callable function invocation result is a Tuple of two elements:

List of script actions. Actions are executed in the same order as the elements in the list.
Return value that is passed to the invoking function in case of the dApp-to-dApp invocation.
Example:

(
  [
    BooleanEntry("key1", true),
    IntegerEntry("key2", 42),
    StringEntry("key3", "some string"),
    BinaryEntry("key4", base58'encoded'),
    DeleteEntry("key5"),
    ScriptTransfer(Address(base58'3Ms8fSfAxBLDjKvNVgACRzQoBLCtCWxtawu'), 100, base58'someAssetid'),
    Issue("RegularToken", "This is an ordinary token", 10000, 2, true),
    Reissue("4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV", 1000, true),
    Burn("4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV", 1000)]
    SponsorFee("4ZzED8WJXsvuo2MEm2BmZ87Azw8Sx7TVC6ufSUA5LyTV", 300),
    Lease(Address(base58'3Mn5hzck8nYd52Ytd2ZjzoiQLVoMcn1VAs9',1000),
    LeaseCancel(base58'Pxaf8pGKHS5ufGhqjmwRRcHQtC9T3h4d1XaJMnkhR1Vt')
  ],
  42
)
Script Actions
Script actions performed by the callable function are set by Ride structures.

Ride structure that sets action	Description
BinaryEntry
BooleanEntry
IntegerEntry
StringEntry	Adding/modifying the entry. The type of structure must match the type of entry to be added/changed.
- If there is no entry in the account data storage with the key specified in the structure, the entry will be added.
- If the entry is present in the account data storage, it will be modified
DeleteEntry	Entry deletion
Issue	Token issue
Reissue	Token reissue
Burn	Token burn
SponsorFee	Sponsorship setup
ScriptTransfer	Token transfer
Lease	Lease
LeaseCancel	Lease cancellation
Limitations
The maximum total number of Issue, Reissue, Burn, SponsorFee, ScriptTransfer, Lease, LeaseCancel script actions executed by all callable functions in a single transaction is 100.
The maximum total number of BinaryEntry, BooleanEntry, IntegerEntry, StringEntry, DeleteEntry script actions executed by all callable functions in a single transaction is 100.
The maximum number of payments attached to an invocation is 10. The maximum total number of payments attached to dApp script invocations in a single transaction is 100.
See also the Limitations article.

Example
The example listed below is a wallet application which allows to send WAVES to a certain address and withdraw them (withdrawing others' WAVES is prevented). There are two callable functions in the example:

deposit — deposits the tokens.
withdraw — withdraws the tokens.
{-# STDLIB_VERSION 8 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

@Callable(i)
func deposit() = {
  let pmt =
    if i.payments.size() == 1 then
      i.payments[0]
    else throw("Attached payment is required")
  if (isDefined(pmt.assetId))
    then throw("works with waves only")
    else {
     let currentKey = toBase58String(i.caller.bytes)
     let currentAmount = match getInteger(this, currentKey) {
       case a:Int => a
       case _ => 0
     }
     let newAmount = currentAmount + pmt.amount
     (
       [
         IntegerEntry(currentKey, newAmount)
       ],
       unit
     )
   }
}

@Callable(i)
func withdraw(amount: Int) = {
  let currentKey = toBase58String(i.caller.bytes)
  let currentAmount = match getInteger(this, currentKey) {
    case a:Int => a
    case _ => 0
  }
  let newAmount = currentAmount - amount
  if (amount < 0)
    then throw("Can't withdraw negative amount")
    else if (newAmount < 0)
      then throw("Not enough balance")
      else (
        [
          IntegerEntry(currentKey, newAmount),
          ScriptTransfer(i.caller, amount, unit)
        ],
        unit
      )
}

@Verifier(tx)
func verify() = false
Threshold for Saving Failed Transactions
The Invoke Script transaction is saved on the blockchain and a fee is charged for it even if the dApp script or the asset script failed when a block generator adds the transaction to a block, provided that the sender's signature or account script verification passed.

However, if the callable function failed or threw an exception before the complexity of performed calculations exceeded the threshold for saving failed transactions, the transaction is discarded and the fee is not charged.

This rule is applied after activation of feature #15 “Ride V4, VRF, Protobuf, Failed transactions” and doesn't depend on the Standard library version used. Keep it in mind when developing a dApp script. For more information, see the Transaction Validation article.

Default Callable Function
The default callable function is a function that is named default and has no arguments:

@Callable(i)
func default() = {
   ...
}
If the default callable function is defined in a dApp script, and no call field is specified in an Invoke Script transaction, the default function is invoked.

Verifier Function
Verifier function is a function of dApp script that is responsible for verification of transactions and orders sent from dApp account. The verifier function does the same as an account script.

dApp script can have only one verifier function. The verifier function should be adorned with the @Verifier(tx) annotation, where tx: Transaction|Order is the transaction or the order that the function is currently checking.

Verifier function has no arguments.

Verifier function can have one of the following execution results:

true (the transaction or the order is allowed),
false (the transaction or the order is denied),
an error (the transaction or the order is denied).
dApp that has no verifier function performs default verification, that is, checking that the first proof of the transaction/order has the correct sender's signature. The following function does the same as the default implementation:

@Verifier(tx)
func verify() = {
    sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
}
If the verifier function is defined, only verification by this function is performed, proofs are not checked additionally.

⚠️ If the the complexity of the verifier function exceeds the sender complexity threshold, the minimum fee for transactions sent on behalf of the account is increased by 0.004 WAVES. (Before activation of feature #16 “Ride V5, dApp-to-dApp invocations”, the extra fee was required regardless of the presence and complexity of the verifier function.)

Data Accessible to Verifier Function
Fields of the current verified transaction/order, including proofs. The built-in variable tx contains this transaction or order. The set of fields depends on the type of transaction/order, see the Transaction Structures chapter and Order article.

Blockchain data: current height, account balances, entries in account data storages, parameters of tokens, etc.

⚠️ Blockchain data is available only when checking a transaction and not available when checking an order (case t: Order).

Example
dApp with the verifier function listed below only allows transfer transactions with amount of token less than 100. Orders and other transactions are denied. The match operator is used to specify verification rules depending on the type of the transaction/order.

@Verifier(tx)
func verify() = {
    match tx {
        case ttx:TransferTransaction => ttx.amount < 100 && sigVerify(ttx.bodyBytes, ttx.proofs[0], ttx.senderPublicKey)
        case _ => false
    }
}

Standard Library
Standard library is a set of built-in functions, structures and variables.

The version of the Standard library in the script is set by the STDLIB_VERSION directive.

We recommend to use version 8 of the Standard Library when developing applications.

Key Features of Version 8
Standard library is enabled by feature #22 “Light Node”.

Added built-in functions:
replaceByIndex — replaces an element in the list at a given index.
calculateDelay — calculates the time delay before generating a block.
Added the attachment field to the Order structure.
Reduced the complexity of functions and operators having BigInt arguments.
Key Features of Version 7
Version 7 is enabled by feature #19 “Block Reward Distribution”.

Added the rewards: List[(Address, Int)] field to the BlockInfo structure which is returned by the blockInfoByHeight built-in function.

Key Features of Version 6
Version 6 is enabled by feature #17 “Ride V6, MetaMask support”.

MetaMask Support
The addressFromPublicKey function accepts both Waves account public key (32 bytes) and the MetaMask account public key (64 bytes) and returns address in Waves format (26 bytes).
The transferTransactionById function returns an Ethereum transaction by its ID if the transaction is interpreted as a Transfer transaction. The proofs array contains 8 empty values.
More about MetaMask support on the Waves blockchain

Changes in Functions
The maximum complexity of a callable function of a dApp script in Standard library version 6 is changed to 52,000.

The maximum total complexity of all callable functions and asset scripts within an Invoke Script transaction depends on the version of Standard library in the first dApp script invoked:

If the first dApp script uses version 6, the total complexity is limited by 52 000.
If the first dApp script uses version 5, the total complexity is limited by 26 000. If script version 6 functions are invoked next, their complexity can exceed 10,000 and is limited only by the total complexity of the transaction.
The sender's account script complexity is not included in that limit.

The maximum total number of ScriptTransfer, Lease, LeaseCancel script actions executed by all callable functions in a single transaction is 100.

The maximum total number of Issue, Reissue, Burn, SponsorFee script actions executed by all callable functions in a single transaction is 30.

Callable functions no longer accept arguments of type Union.

Added the following built-in functions:

sqrt(Int,Int,Int,Union)
sqrt(BigInt,Int,Int,Union)
Changed the limitation on the second parameter of drop,dropRight, take,takeRight functions:

for string functions a number from 0 to 32,767 (the maximum string length) is allowed,
for byte array functions a number from 0 to 165 947 (the maximum byte array length) is allowed.
Changed the limitations on input and output data size for the built-in string functions makeString and split; their complexity reduced to 1. Added the range of similar functions with different complexity depending on the data size.

Changed the complexity of certain built-in functions. The complexity is given in the Built-in functions article.

Miscellaneous
New complexity estimation rules reduce overall script complexity.
See also the [Ride v5, v4, v3] Previous Versions of Standard Library article.

Data types
Data type name	Ride keyword
Big Integer	BigInt
Boolean	Boolean
Byte array	ByteVector
Integer	Int
String	String
Empty value	Unit
List	List
Tuple	—
Union	—
Structure	—
Arbitrary type	Any
For each value, depending on the data type, the weight is determined. The weight is used in limitations on creating and comparing values. For more information see the Data Weight.

Script actions
Script actions are executed, that is, they make changes on the blockchain only if they are included in the resulting expression of the callable function. See more details in the Callable function article.

Action	Description
BinaryEntry	Add or modify a binary entry of the account data storage
BooleanEntry	Add or modify a boolean entry
Burn	Burn a token
DeleteEntry	Delete an entry
IntegerEntry	Add or modify an integer entry
Issue	Issue a token
Lease	Lease
LeaseCancel	Cancel lease
Reissue	Reissue a token
ScriptTransfer	Transfer a token
SponsorFee	Set up a sponsorship
StringEntry	Add or modify a string entry
Available script actions depend on Standard library version used.

Limitations on the total number of script actions and the total size of data entries are given in the Limitations article.

Built-in functions
A built-in function is a function of the Standard library.

Account data storage functions
Name	Description	Complexity
getBinary(Address|Alias, String): ByteVector|Unit	Gets an array of bytes by key	10
getBinary(String): ByteVector|Unit	Gets an array of bytes by key from dApp's own data storage	10
getBinaryValue(Address|Alias, String): ByteVector	Gets an array of bytes by key. Fails if there is no data	10
getBinaryValue(String): ByteVector	Gets an array of bytes by key from dApp's own data storage. Fails if there is no data	10
getBoolean(Address|Alias, String): Boolean|Unit	Gets a boolean value by key	10
getBoolean(String): Boolean|Unit	Gets a boolean value by key from dApp's own data storage	10
getBooleanValue(Address|Alias, String): Boolean	Gets a boolean value by key. Fails if there is no data	10
getBooleanValue(String): Boolean	Gets a boolean value by key from dApp's own data storage. Fails if there is no data	10
getInteger(Address|Alias, String): Int|Unit	Gets an integer by key	10
getInteger(String): Int|Unit	Gets an integer by key from dApp's own data storage	10
getIntegerValue(Address|Alias, String): Int	Gets an integer by key. Fails if there is no data	10
getIntegerValue(String): Int	Gets an integer by key from dApp's own data storage. Fails if there is no data	10
getString(Address|Alias, String): String|Unit	Gets a string by key	10
getString(String): String|Unit	Gets a string by key from dApp's own data storage	10
getStringValue(Address|Alias, String): String	Gets a string by key. Fails if there is no data	10
getStringValue(String): String	Gets a string by key from dApp's own data storage. Fails if there is no data	10
isDataStorageUntouched(Address|Alias): Boolean	Checks if the data storage of a given account never contained any entries	10
Blockchain functions
Name	Description	Complexity
addressFromRecipient(Address|Alias): Address	Gets the corresponding address of the alias	5
assetBalance(Address|Alias, ByteVector): Int	Gets account balance by an asset ID	10
assetInfo(ByteVector): Asset|Unit	Gets asset parameters by its ID	15
blockInfoByHeight(Int): BlockInfo |Unit	Gets the information about a block by the block height	5
calculateAssetId(Issue): ByteVector	Calculates ID of the token formed by the Issue structure when executing the callable function	10
calculateDelay(ByteVector, Int, Address, Int): Int	Calculates the time delay before generating a block	1
calculateLeaseId(Lease): ByteVector	Calculates ID of the lease formed by the Lease structure when executing the callable function	1
scriptHash(Address|Alias): ByteVector|Unit	Returns BLAKE2b-256 hash of the script assigned to a given account	200
transactionHeightById(ByteVector): Int|Unit	Gets the block height of a transaction	20
transferTransactionById(ByteVector): TransferTransaction|Unit	Gets the data of a transfer transaction	60
wavesBalance(Address|Alias): BalanceDetails	Gets account balance in WAVES	10
Byte array functions
Name	Description	Complexity
drop(ByteVector, Int): ByteVector	Returns a given byte array without the first N bytes	6
dropRight(ByteVector, Int): ByteVector	Returns a given byte array without the last N bytes	6
size(ByteVector): Int	Returns the number of bytes in a byte array	1
take(ByteVector, Int): ByteVector	Returns the first N bytes of the byte array	6
takeRight(ByteVector, Int): ByteVector	Returns the last N bytes of the byte array	6
Converting functions
Name	Description	Complexity
addressFromPublicKey(ByteVector): Address	Converts account public key to address	1
parseBigInt(String): BigInt|Unit	Converts the string representation of a number to its big integer equivalent	1 for Standard library version 8
65 for Standard library version 7 or 6
parseBigIntValue(String): BigInt	Converts the string representation of a number to its big integer equivalent.
Fails if the string cannot be parsed	1 for Standard library version 8
65 for Standard library version 7 or 6
parseInt(String): Int|Unit	Converts the string representation of a number to its integer equivalent	2
parseIntValue(String): Int	Converts the string representation of a number to its integer equivalent. Fails if the string cannot be parsed	2
toBigInt(ByteVector): BigInt	Converts an array of bytes to a big integer	1 for Standard library version 8
65 for Standard library version 7 or 6
toBigInt(ByteVector, Int, Int): BigInt	Converts an array of bytes starting from a certain index to a big integer	1 for Standard library version 8
65 for Standard library version 7 or 6
toBigInt(Int): BigInt	Converts an integer to a big integer	1
toBytes(Boolean): ByteVector	Converts a boolean to an array of bytes	1
toBytes(Int): ByteVector	Converts an integer to an array of bytes	1
toBytes(String): ByteVector	Converts a string to an array of bytes	8
toBytes(BigInt): ByteVector	Converts a big integer to an array of bytes	1 for Standard library version 8
65 for Standard library version 7 or 6
toInt(BigInt): Int	Converts a big integer to an integer.
Fails if the number cannot be converted	1
toInt(ByteVector): Int	Converts an array of bytes to an integer	1
toInt(ByteVector, Int): Int	Converts an array of bytes to an integer starting from a certain index	1
toString(Address): String	Converts an address to a string	1
toString(BigInt): String	Converts a big integer to a string	1
toString(Boolean): String	Converts a boolean to a string	1
toString(Int): String	Converts an integer to a string	1
toUtf8String(ByteVector): String	Converts an array of bytes to a UTF-8 string	7
transferTransactionFromProto(ByteVector): TransferTransaction|Unit	Deserializes transfer transaction	5
dApp-to-dApp invocation functions
Name	Description	Complexity
invoke(Address|Alias, String, List[Any], List[AttachedPayments]): Any	Invokes a dApp callable function, with reentrancy restriction	75
reentrantInvoke(Address|Alias, String, List[Any], List[AttachedPayments]): Any	Invokes a dApp callable function, without reentrancy restriction	75
Data transaction functions
Name	Description	Complexity
getBinary(List[], String): ByteVector|Unit	Gets a binary value from a list of data entires by key	10
getBinary(List[], Int): ByteVector|Unit	Gets a binary value from a list of data entires by index	4
getBinaryValue(List[], String): ByteVector	Gets a binary value from a list of data entires by key. Fails if there is no data	10
getBinaryValue(List[], Int): ByteVector	Gets a binary value from a list of data entires by index. Fails if there is no data	4
getBoolean(List[], String): Boolean|Unit	Gets a boolean value from a list of data entires by key	10
getBoolean(List[], Int): Boolean|Unit	Gets a boolean value from a list of data entires by index	4
getBooleanValue(List[], String): Boolean	Gets a boolean value from a list of data entires by key. Fails if there is no data	10
getBooleanValue(List[], Int): Boolean	Gets a boolean value from a list of data entires by index. Fails if there is no data	4
getInteger(List[], String): Int|Unit	Gets an integer value from a list of data entires by key	10
getInteger(List[], Int): Int|Unit	Gets an integer value from a list of data entires by index	4
getIntegerValue(List[], String): Int	Gets an integer value from a list of data entires by key. Fails if there is no data	10
getIntegerValue(List[], Int): Int	Gets an integer value from a list of data entires by index. Fails if there is no data	4
getString(List[] String): String|Unit	Gets a string value from a list of data entires by key	10
getString(List[], Int): String|Unit	Gets a string value from a list of data entires by index	4
getStringValue(List[], String): String	Gets a string value from a list of data entires by key. Fails if there is no data	10
getStringValue(List[], Int): String	Gets a string value from a list of data entires by index. Fails if there is no data	4
Decoding functions
Name	Description	Complexity
addressFromString(String): Address|Unit	Decodes address from base58 string	1
addressFromStringValue(String): Address	Decodes address from base58 string. Fails if the address cannot be decoded	1
fromBase16String(String): ByteVector	Decodes base16 string to an array of bytes	10
fromBase58String(String): ByteVector	Decodes base58 string to an array of bytes	1
fromBase64String(String): ByteVector	Decodes base64 string to an array of bytes	40
Encoding functions
Name	Description	Complexity
toBase16String(ByteVector): String	Encodes array of bytes to base16 string	10
toBase58String(ByteVector): String	Encodes array of bytes to base58 string	3
toBase64String(ByteVector): String	Encodes array of bytes to base64 string	35
Exception functions
Name	Description	Complexity
throw()	Raises an exception	1
throw(String)	Raises an exception with a message	1
Hashing functions
Name	Description	Complexity
blake2b256(ByteVector): ByteVector	Range of functions.
Hash an array of bytes using BLAKE2b-256	13–136
keccak256(ByteVector): ByteVector	Range of functions.
Hash an array of bytes using Keccak-256	20–195
sha256(ByteVector): ByteVector	Range of functions.
Hash an array of bytes using SHA-256	12–118
List functions
Name	Description	Complexity
cons(A, List[B]): List[A|B]	Inserts element to the beginning of the list	1
containsElement(list: List[T], element: T): Boolean	Check if the element is in the list	5
getElement(List[T], Int): T	Gets element from the list	2
indexOf(List[T], T): Int|Unit	Returns the index of the first occurrence of the element in the list	5
lastIndexOf(List[T], T): Int|Unit	Returns the index of the last occurrence of the element in the list	5
max(List[Int]): Int	Returns the largest element in the list of integers	3
max(List[BigInt]): BigInt	Returns the largest element in the list of big integers	6 for Standard library version 8
192 for Standard library version 7 or 6
min(List[Int]): Int	Returns the smallest element in the list of integers	3
min(List[BigInt]): BigInt	Returns the smallest element in the list of big integers	6 for Standard library version 8
192 for Standard library version 7 or 6
removeByIndex(List[T], Int): List[T]	Removes an element from a list at the given index	4 for Standard library version 8
7 for Standard library version 7 or 6
replaceByIndex(List[T], Int, T): List[T]	Replaces an element in the list at a given index	4
size(List[T]): Int	Returns the size of the list	2
A, B, T means any valid type.

Math functions
Name	Description	Complexity
fraction(Int, Int, Int): Int	Multiplies and divides integers to avoid overflow	1
fraction(Int, Int, Int, Union): Int	Multiplies and divides integers to avoid overflow, applying the specified rounding method	1
fraction(BigInt, BigInt, BigInt): BigInt	Multiplies and divides big integers to avoid overflow	1
fraction(BigInt, BigInt, BigInt, Union): BigInt	Multiplies and divides big integers to avoid overflow, applying the specified rounding method	1
log(Int, Int, Int, Int, Int, Union): Int	Calculates logarithm of a number with a base	100
log(BigInt, Int, BigInt, Int, Int, Union): BigInt	Calculates logarithm of a number to a given base with high accuracy	200
median(List[Int]): Int	Returns the median of a list of integers	20
median(List[BigInt]): BigInt	Returns the median of a list of big integers	35 for Standard library version 8
160 for Standard library version 7 or 6
pow(Int, Int, Int, Int, Int, Union): Int	Raises a number to a given power	28
pow(BigInt, Int, BigInt, Int, Int, Union): BigInt	Raises a number to a given power with high accuracy	270
sqrt(Int, Int, Int, Union): Int	Returns the square root of a number	2
sqrt(BigInt, Int, Int, Union): BigInt	Returns the square root of a number with high accuracy	5
String functions
Name	Description	Complexity
contains(String, String): Boolean	Checks whether the string contains substring	3
drop(String, Int): String	Returns a given string without the first N characters	20
dropRight(String, Int): String	Returns a given string without the last N characters	20
indexOf(String, String): Int|Unit	Returns the index of the first occurrence of a substring	3
indexOf(String, String, Int): Int|Unit	Returns the index of the first occurrence of a substring after a certain index	3
lastIndexOf(String, String): Int|Unit	Returns the index of the last occurrence of a substring	3
lastindexOf(String, String, Int): Int|Unit	Returns the index of the last occurrence of a substring before a certain index	3
makeString(List[String], String): String	Range of functions.
Concatenate list strings adding a separator	1–11
size(String): Int	Returns the size of a string	1
split(String, String): List[String]	Range of functions.
Split a string delimited by a separator into a list of substrings	1–51
take(String, Int): String	Takes the first N characters from a string	20
takeRight(String, Int): String	Takes the last N characters from a string	20
Union functions
Name	Description	Complexity
isDefined(T|Unit): Boolean	Checks if an argument is not unit	1
value(T|Unit): T	Gets a value from a union type argument. Fails if it is unit	2
valueOrElse(T|Unit, T): T	Returns a value from a union type argument if it's not unit. Otherwise, returns the second argument	2
valueOrErrorMessage(T|Unit, String): T	Gets a value from a union type argument if it's not unit. Otherwise, fails with the message specified in the second argument	2
Verification functions
Name	Description	Complexity
bn256Groth16Verify(ByteVector, ByteVector, ByteVector): Boolean	Range of functions.
Check zk-SNARK by groth16 protocol on the bn254 curve	800–1650
createMerkleRoot(List[ByteVector], ByteVector, Int) : ByteVector	Calculates the Merkle root hash for transactions of block	30
ecrecover(messageHash: ByteVector, signature: ByteVector)	Recovers public key from the message hash and the ECDSA digital signature	70
groth16Verify(ByteVector, ByteVector, ByteVector): Boolean	Range of functions.
Check zk-SNARK by groth16 protocol on the bls12-381 curve	1200–2700
rsaVerify(digestAlgorithmType, ByteVector, ByteVector, ByteVector): Boolean	Range of functions.
Check that the RSA digital signature is valid, i.e. it was created by the owner of the public key	500–1000
sigVerify(ByteVector, ByteVector, ByteVector): Boolean	Range of functions.
Check that the Curve25519 digital signature is valid, i.e. it was created by the owner of the public key	43–180

Math functions
Name	Description	Complexity
fraction(Int, Int, Int): Int	Multiplies and divides integers to avoid overflow	1
fraction(Int, Int, Int, Union): Int	Multiplies and divides integers to avoid overflow, applying the specified rounding method	1
fraction(BigInt, BigInt, BigInt): BigInt	Multiplies and divides big integers to avoid overflow	1
fraction(BigInt, BigInt, BigInt, Union): BigInt	Multiplies and divides big integers to avoid overflow, applying the specified rounding method	1
log(Int, Int, Int, Int, Int, Union): Int	Calculates logarithm of a number to a given base	100
log(BigInt, Int, BigInt, Int, Int, Union): BigInt	Calculates logarithm of a number to a given base with high accuracy	200
median(List[Int]): Int	Returns the median of a list of integers	20
median(List[BigInt]): BigInt	Returns the median of a list of big integers	35 for Standard library version 8
160 for Standard library version 7 or 6
pow(Int, Int, Int, Int, Int, Union): Int	Raises a number to a given power	28
pow(BigInt, Int, BigInt, Int, Int, Union): BigInt	Raises a number to a given power with high accuracy	270
sqrt(Int, Int, Int, Union): Int	Returns the square root of a number	2
sqrt(BigInt, Int, Int, Union): BigInt	Returns the square root of a number with high accuracy	5
fraction(Int, Int, Int): Int
Multiplies integers a, b and divides the result by the integer c to avoid overflow.

Fraction a × b / c should not exceed the maximum value of the integer type 9,223,372,036,854,755,807.

The rounding method is DOWN, see Rounding variables below.

fraction(a: Int, b: Int, c: Int): Int
Parameters
Parameter	Description
a: Int	Integer a
b: Int	Integer b
c: Int	Integer c
Example
Lets assume that:

a = 100,000,000,000,

b = 50,000,000,000,000,

c = 2,500,000.

The following formula, with operators * and /, fails due to overflow:

a * b / c #  overflow, because a × b exceeds max integer value
The fraction function with no overflow:

fraction(a, b, c) # Result: 2,000,000,000,000,000,000
fraction(Int, Int, Int, Union): Int
Multiplies integers a, b and divides the result by the integer c to avoid overflow, applying the specified rounding method.

Fraction a × b / c should not exceed the maximum value of the integer type 9,223,372,036,854,755,807.

fraction(a: Int, b: Int, c: Int, round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN): Int
Parameters
Parameter	Description
a: Int	Integer a
b: Int	Integer b
c: Int	Integer c
round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN	One of the rounding variables
fraction(BigInt, BigInt, BigInt): BigInt
Multiplies big integers a, b and divides the result by the integer c to avoid overflow.

Fraction a × b / c should not exceed the maximum value of the big integer type.

The rounding method is DOWN, see Rounding variables below.

fraction(a: BigInt, b: BigInt, c: BigInt): BigInt
Parameters
Parameter	Description
a: BigInt	Big integer a
b: BigInt	Big integer b
c: BigInt	Big integer c
fraction(BigInt, BigInt, BigInt, Union): BigInt
Multiplies big integers a, b and divides the result by the integer c to avoid overflow, applying the specified rounding method.

Fraction a × b / c should not exceed the maximum value of the big integer type.

fraction(a: BigInt, b: BigInt, c: BigInt, round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN): BigInt
Parameters
Parameter	Description
a: BigInt	Big integer a
b: BigInt	Big integer b
c: BigInt	Big integer c
round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN	One of the rounding variables
log(Int, Int, Int, Int, Int, Union): Int
Calculates logba.

log(value: Int, vp: Int, base: Int, bp: Int, rp: Int, round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN): Int
In Ride, there is no data type with the floating point. That is why, for example, when you need to calculate log2.716.25 then the number value = 1625, vp = 2 and the base = 27, bp = 1.

More examples:

a	value	vp
16.25	1625	2
5	5	0
5.00	500	2
If the log function returns, for example, 2807, and the parameter rp = 3, then the result is 2.807; in the number 2807 the last 3 digits is a fractional part.

Parameters
Parameter	Description
value: Int	Number a without decimal point
vp: Int	Number of decimals of a, from 0 to 8 inclusive
base: Int	Logarithm base b without decimal point
bp: Int	Number of decimals of b, from 0 to 8 inclusive
rp: Int	Number of decimals in the resulting value, from 0 to 8 inclusive. Specifies the accuracy of the calculated result
round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN	One of the rounding variables
Examples
log2.716.25 = 2.807035421...

log(1625, 2, 27, 1, 2, HALFUP) # Function returns 281, so the result is: 2.81
log(1625, 2, 27, 1, 5, HALFUP) # Function returns 280703542, so the result is: 2.80704
log(0, 0, 2, 0, 0, HALFUP)     # Result: -Infinity
log(BigInt, Int, BigInt, Int, Int, Union): BigInt
Calculates logba with high accuracy.

log(value: BigInt, vp: Int, base: BigInt, bp: Int, rp: Int, round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN): BigInt
In Ride, there is no data type with the floating point. That is why, for example, when you need to calculate log2.716.25 then value = 1625, vp = 2 and the base = 27, bp = 1.

If the log function returns, for example, 2807035420964590265, and the parameter rp = 18, then the result is 2.807035420964590265; in the number 2807035420964590265 the last 18 digits is a fractional part.

Parameters
Parameter	Description
value: BigInt	Number a without decimal point
vp: Int	Number of decimals of a, from 0 to 18 inclusive
base: BigInt	Logarithm base b without decimal point
bp: Int	Number of decimals of b, from 0 to 18 inclusive
rp: Int	Number of decimals in the resulting value, from 0 to 18 inclusive. Specifies the accuracy of the calculated result
round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN	One of the rounding variables
median(List[Int]): Int
Returns the median of the list of integers. Fails if the list is empty.

median(arr: List[Int]): Int
Parameters
Parameter	Description
arr: List[Int]	List of integers
Examples
median([1, 2, 3])         # Returns 2
median([2, 4, 9, 20])     # Returns 6
median([-2, -4, -9, -20]) # Returns -7
median(List[BigInt]): BigInt
Returns the median of a list of big integers. Fails if the list is empty or contains more than 100 elements.

median(arr: List[BigInt]): BigInt
Parameters
Parameter	Description
arr: List[BigInt]	List of big integers
pow(Int, Int, Int, Int, Int, Union): Int
Calculates ab.

pow(base: Int, bp: Int, exponent: Int, ep: Int, rp: Int, round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN): Int
In Ride, there is no data type with the floating point. That is why, for example, when you need to calculate 16.252.7, then the number base = 1625, bp = 2, and the exponent = 27, ep = 1.

If the pow function returns, for example, 18591057, and the parameter rp = 4, then the result is 1859.1057; in the number 18591057 the last 4 digits is a fractional part.

Parameters
Parameter	Description
base: Int	Number a without decimal point
bp: Int	Number of decimals of a, from 0 to 8 inclusive
exponent: Int	Exponent b without decimal point
ep: Int	Number of decimals of b, from 0 to 8 inclusive
rp: Int	Number of decimals in the resulting value, from 0 to 8 inclusive. Specifies the accuracy of the calculated result
round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN	One of the rounding variables
Examples
16.252.7 = 1859,1057168...

pow(1625, 2, 27, 1, 2, HALFUP) # function returns 185911, so the result is: 1859.11
pow(1625, 2, 27, 1, 5, HALFUP) # function returns 185910572, so, the result is: 1859.10572
pow(BigInt, Int, BigInt, Int, Int, Union): BigInt
Calculates ab with high accuracy.

pow(base: BigInt, bp: Int, exponent: BigInt, ep: Int, rp: Int, round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN): BigInt
In Ride, there is no data type with the floating point. That is why, for example, when you need to calculate 16.252.7, then the number base = 1625, bp = 2, and the exponent = 27, ep = 1.

If the pow function returns, for example, 1859105716849757217692, and the parameter rp = 18, then the result is 1859.105716849757217692; in the number 1859105716849757217692 the last 18 digits is a fractional part.

Parameters
Parameter	Description
base: BigInt	Number a without decimal point
bp: Int	Number of decimals of a, from 0 to 18 inclusive
exponent: BigInt	Exponent b without decimal point
ep: Int	Number of decimals of b, from 0 to 18 inclusive
rp: Int	Number of decimals in the resulting value, from 0 to 18 inclusive. Specifies the accuracy of the calculated result
round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN	One of the rounding variables
sqrt(Int, Int, Int, Union): Int
Calculates the square root of a number: √a.

sqrt(base: Int, bp: Int, rp: Int, round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN): Int
In Ride, there is no data type with the floating point. That is why, for example, when you need to calculate √16.25, specify base = 1625 and bp = 2.

If the sqrt function returns, for example, 40311, and the parameter rp = 4, then the result is 4.0311; in the number 40311 the last 4 digits is a fractional part.

Parameters
Parameter	Description
base: Int	Number a without decimal point
bp: Int	Number of decimals of a
rp: Int	Number of decimals in the resulting value, from 0 to 8 inclusive. Specifies the accuracy of the calculated result
round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN	One of the rounding variables
Examples
√16,25 = 4,03112887...

sqrt(1625, 2, 2, HALFUP) # function returns 403, so the result is 4.03
sqrt(1625, 2, 5, HALFUP) # function returns 403113, so the result is 4.03113
sqrt(BigInt, Int, Int, Union): BigInt
Calculates the square root of a number with high accuracy.

sqrt(base: BigInt, bp: Int, rp: Int, round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN): BigInt
In Ride, there is no data type with the floating point. That is why, for example, when you need to calculate √16.25, specify base = 1625 and bp = 2.

If the sqrt function returns, for example, 4031128874149274826, and the parameter rp = 18, then the result is 4.031128874149274826; in the number 4031128874149274826 the last 18 digits is a fractional part.

Parameters
Parameter	Description
base: BigInt	Number a without decimal point
bp: Int	Number of decimals of a
rp: Int	Number of decimals in the resulting value, from 0 to 18 inclusive. Specifies the accuracy of the calculated result
round: DOWN|CEILING|FLOOR|HALFUP|HALFEVEN	One of the rounding variables
Rounding Variables
Below is the list of built-in rounding variables. Every variable corresponds to the rounding method.

The rounding variables are only used as the parameters of functions fraction, log, pow.

Name	Description
DOWN	Rounds towards zero
CEILING	Rounds towards positive infinity
FLOOR	Rounds towards negative infinity
HALFUP	Rounds towards the nearest integer; if the integers are equidistant, then rounds away from zero
HALFEVEN	Rounds towards the nearest integer; if the integers are equidistant, then rounds towards the nearest even integer
Examples
Input number/Rounding method	DOWN	CEILING	FLOOR	HALFUP	HALFEVEN
5.5	5	6	5	6	6
2.5	2	3	2	3	2
1.6	1	2	1	2	2
1.1	1	2	1	1	1
1.0	1	1	1	1	1
-1.0	-1	-1	-1	-1	-1
-1.1	-1	-1	-2	-1	-1
-1.6	-1	-1	-2	-2	-2
-2.5	-2	-2	-3	-3	-2
-5.5	-5	-5	-6	-6	-6