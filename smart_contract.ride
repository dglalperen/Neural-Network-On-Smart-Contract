{-# STDLIB_VERSION 5 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let layer1Weights = [[4051769, 4062273], [-5948515, -6010085]]
let layer1Biases = [-6307843, 2229872]
let layer2Weights = [[-8372358, -8139317]]
let layer2Biases = [4083679]

func sigmoid(z: Int) = {
  let e = 2718281 # e approximated to 1e6 precision
  let base = 1000000
  let negativeZ = -1 * z
  let expPart = fraction(e, negativeZ, base) 
  fraction(base, 1000000, base + expPart)
}

func dotProduct(a: List[Int], b: List[Int]) = {
  let product0 = fraction(a[0], b[0], 1000000)
  let product1 = fraction(a[1], b[1], 1000000)
  product0 + product1
}

func forwardPass(input: List[Int], weights: List[List[Int]], biases: List[Int]) = {
  let sum0 = dotProduct(input, weights[0]) + biases[0]
  let sum1 = dotProduct(input, weights[1]) + biases[1]
  let sig0 = sigmoid(sum0)
  let sig1 = sigmoid(sum1)
  [sig0, sig1]
}

func xorNeuralNetwork(input1: Int, input2: Int) = {
  let input = [input1, input2]
  let hiddenLayerOutput = forwardPass(input, layer1Weights, layer1Biases)
  let outputLayerSum = dotProduct(hiddenLayerOutput, layer2Weights[0]) + layer2Biases[0]
  let output = sigmoid(outputLayerSum)
  output
}

@Callable(i)
func predict(inputData: Int) = {
  let input1 = if(inputData == 0 || inputData == 1) then 0 else 1000000
  let input2 = if(inputData == 0 || inputData == 2) then 0 else 1000000
  let result = xorNeuralNetwork(input1, input2)
  [IntegerEntry("result", result)]
}
